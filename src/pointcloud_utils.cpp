#include "diplom/pointcloud_utils.h"

#include <ros/ros.h> 
#include <fstream>
#include <sstream>
#include <iomanip>
#include <algorithm>
#include <cctype>
#include <cmath>
#include <numeric> 
#include <functional> 

std::size_t VoxelIndexHash::operator()(const VoxelIndex& idx) const {
    size_t seed = 0;
    std::hash<int> hasher;
    seed ^= hasher(idx.x) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
    seed ^= hasher(idx.y) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
    seed ^= hasher(idx.z) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
    return seed;
}

bool loadPlyFile(const std::string& filename, PointCloud& cloud) {
    cloud.clear();
    std::ifstream ifs(filename);
    if (!ifs.is_open()) {
        ROS_ERROR("[Utils] Could not open PLY file: %s", filename.c_str());
        return false;
    }

    std::string line;
    long point_count = 0;
    int property_count = 0;
    bool header_parsed = false;
    bool format_ok = false;
    bool properties_ok = false;
    bool vertex_element_found = false;

    while (std::getline(ifs, line)) { // Read header
        if (!line.empty() && line.back() == '\r') line.pop_back();
        if (line.empty()) continue;
        std::stringstream ss(line); std::string keyword; ss >> keyword;
        if (keyword == "ply") continue;
        if (keyword == "format") { std::string fmt; double ver; ss >> fmt >> ver; if (fmt == "ascii" && ver >= 1.0) format_ok = true; else { ROS_ERROR("[Utils] Unsupported PLY format in %s.", filename.c_str()); ifs.close(); return false; } }
        else if (keyword == "comment") continue;
        else if (keyword == "element") { std::string name; long count; ss >> name >> count; if (name == "vertex") { vertex_element_found = true; point_count = count; if (point_count < 0) { ROS_ERROR("[Utils] Negative vertex count in %s.", filename.c_str()); ifs.close(); return false;} } }
        else if (keyword == "property" && vertex_element_found) { std::string type, name; ss >> type >> name; std::transform(name.begin(), name.end(), name.begin(), ::tolower); if ((type == "float" || type == "double" || type == "float32" || type == "float64") && (name == "x" || name == "y" || name == "z")) { if (++property_count >= 3) properties_ok = true; } }
        else if (keyword == "end_header") { header_parsed = true; break; }
        else { ROS_WARN("[Utils] Ignoring header line in %s: %s", filename.c_str(), line.c_str()); }
    }
    if (!header_parsed) { ROS_ERROR("[Utils] No 'end_header' in %s.", filename.c_str()); ifs.close(); return false; }
    if (!format_ok) { ROS_ERROR("[Utils] PLY format line missing/invalid in %s.", filename.c_str()); ifs.close(); return false; }
    if (!vertex_element_found) { ROS_ERROR("[Utils] Missing 'element vertex' in %s.", filename.c_str()); ifs.close(); return false; }
    if (point_count == 0) { ROS_INFO("[Utils] PLY file %s loaded successfully (0 vertices).", filename.c_str()); ifs.close(); return true; }
    if (!properties_ok) { ROS_ERROR("[Utils] Valid vertex properties (x,y,z) not found in %s.", filename.c_str()); ifs.close(); return false; }

    cloud.reserve(point_count); // Read point data
    for (long i = 0; i < point_count; ++i) {
        if (!std::getline(ifs, line)) { ROS_ERROR("[Utils] Premature EOF in %s. Expected %ld points, read %ld.", filename.c_str(), point_count, (long)cloud.size()); ifs.close(); return false; }
        if (!line.empty() && line.back() == '\r') line.pop_back();
        if (line.empty()) { i--; ROS_WARN("[Utils] Skipping empty data line in %s at line %ld.", filename.c_str(), i+1); continue; }
        std::stringstream ss(line); Point p;
        if (!(ss >> p.x() >> p.y() >> p.z())) { ROS_ERROR("[Utils] Error parsing point data line %ld in %s: '%s'", i + 1, filename.c_str(), line.c_str()); ifs.close(); return false; }
        cloud.push_back(p);
    }
    ifs.close();
    if (cloud.size() != point_count) { ROS_WARN("[Utils] Read %ld points from %s, header specified %ld.", (long)cloud.size(), filename.c_str(), point_count); }
    ROS_DEBUG("[Utils] Loaded %zu points from %s.", cloud.size(), filename.c_str());
    return true;
}

bool savePlyFile(const std::string& filename, const PointCloud& cloud) {
    std::ofstream ofs(filename);
    if (!ofs.is_open()) { ROS_ERROR("[Utils] Could not open PLY file for writing: %s", filename.c_str()); return false; }
    ofs << "ply\n"; ofs << "format ascii 1.0\n"; ofs << "comment Generated by pointcloud utils\n";
    ofs << "element vertex " << cloud.size() << "\n"; ofs << "property double x\n"; ofs << "property double y\n"; ofs << "property double z\n";
    ofs << "end_header\n";
    ofs << std::fixed << std::setprecision(std::numeric_limits<double>::max_digits10);
    for (const auto& p : cloud) { ofs << p.x() << " " << p.y() << " " << p.z() << "\n"; }
    if (!ofs) { ROS_ERROR("[Utils] Error writing data to PLY file: %s", filename.c_str()); return false; }
    ofs.close();
    if (!ofs) { ROS_ERROR("[Utils] Error closing PLY file: %s", filename.c_str()); return false; }
    ROS_DEBUG("[Utils] Saved %zu points to %s.", cloud.size(), filename.c_str());
    return true;
}

AlignedBoundingBox calculateBoundingBoxEigen(const PointCloud& cloud) {
    AlignedBoundingBox bbox;
    if (cloud.empty()) { ROS_WARN("[Utils] Calculating bounding box for an empty cloud."); }
    else { for (const auto& p : cloud) { bbox.extend(p); } }
    if (!bbox.isEmpty()) { ROS_DEBUG("[Utils] Calculated BBox: Min(%.3f, %.3f, %.3f), Max(%.3f, %.3f, %.3f)", bbox.min().x(), bbox.min().y(), bbox.min().z(), bbox.max().x(), bbox.max().y(), bbox.max().z()); }
    return bbox;
}

VoxelGridMap buildVoxelGrid(const PointCloud& cloud, double leaf_size, const AlignedBoundingBox& bbox) {
    VoxelGridMap grid;
    if (bbox.isEmpty() || leaf_size <= 0.0) { ROS_ERROR("[Utils] Cannot build voxel grid: Invalid bbox or leaf_size (%.4f).", leaf_size); return grid; }
    if (cloud.empty()) { ROS_WARN("[Utils] Building voxel grid for an empty cloud."); return grid; }
    grid.reserve(cloud.size() / 5 + 1);
    const double inv_leaf_size = 1.0 / leaf_size;
    const Point& min_b = bbox.min();
    for (size_t i = 0; i < cloud.size(); ++i) {
        const auto& p = cloud[i];
        int ix = static_cast<int>(std::floor((p.x() - min_b.x()) * inv_leaf_size));
        int iy = static_cast<int>(std::floor((p.y() - min_b.y()) * inv_leaf_size));
        int iz = static_cast<int>(std::floor((p.z() - min_b.z()) * inv_leaf_size));
        grid[{ix, iy, iz}].push_back(i);
    }
    ROS_DEBUG("[Utils] Built Voxel Grid with %zu occupied voxels for %zu points.", grid.size(), cloud.size());
    return grid;
}


std::vector<std::pair<double, size_t>> findKNNSorted(
    const Point& query_point,
    int k,
    const PointCloud& cloud,
    const VoxelGridMap& grid,
    double inv_leaf_size,
    const AlignedBoundingBox& bbox,
    double max_dist_sq)
{
     std::vector<std::pair<double, size_t>> neighbors;
    neighbors.reserve(k * 5);

    if (bbox.isEmpty()) return neighbors;
    const Point& min_b = bbox.min();

    int center_ix = static_cast<int>(std::floor((query_point.x() - min_b.x()) * inv_leaf_size));
    int center_iy = static_cast<int>(std::floor((query_point.y() - min_b.y()) * inv_leaf_size));
    int center_iz = static_cast<int>(std::floor((query_point.z() - min_b.z()) * inv_leaf_size));

    const int search_radius_voxels = 1; 

    for (int dz = -search_radius_voxels; dz <= search_radius_voxels; ++dz) {
        for (int dy = -search_radius_voxels; dy <= search_radius_voxels; ++dy) {
            for (int dx = -search_radius_voxels; dx <= search_radius_voxels; ++dx) {
                VoxelIndex neighbor_voxel_idx = {center_ix + dx, center_iy + dy, center_iz + dz};
                auto it = grid.find(neighbor_voxel_idx);
                if (it != grid.end()) {
                    const std::vector<size_t>& point_indices = it->second;
                    for (size_t candidate_idx : point_indices) {

                        double d_sq = distance_sq(query_point, cloud[candidate_idx]);
                        if (d_sq < max_dist_sq) {
                            neighbors.push_back({d_sq, candidate_idx});
                        }
                    }
                }
            }
        }
    }

    if (neighbors.size() > static_cast<size_t>(k)) {
        std::partial_sort(neighbors.begin(), neighbors.begin() + k, neighbors.end());
        neighbors.resize(k); // Truncate to K
    } else {
        std::sort(neighbors.begin(), neighbors.end());
    }

    return neighbors;
}

int countNeighborsVoxelGrid(
    size_t query_idx,
    const PointCloud& cloud,
    const VoxelGridMap& grid,
    double radius_search_sq,
    double inv_leaf_size,
    const AlignedBoundingBox& bbox)
{
    int neighbor_count = 0;
    if (query_idx >= cloud.size() || bbox.isEmpty()) {
        return 0; 
    }

    const Point& query_point = cloud[query_idx];
    const Point& min_b = bbox.min();

    int center_ix = static_cast<int>(std::floor((query_point.x() - min_b.x()) * inv_leaf_size));
    int center_iy = static_cast<int>(std::floor((query_point.y() - min_b.y()) * inv_leaf_size));
    int center_iz = static_cast<int>(std::floor((query_point.z() - min_b.z()) * inv_leaf_size));

    const int search_radius_voxels = 1; 

    for (int dz = -search_radius_voxels; dz <= search_radius_voxels; ++dz) {
        for (int dy = -search_radius_voxels; dy <= search_radius_voxels; ++dy) {
            for (int dx = -search_radius_voxels; dx <= search_radius_voxels; ++dx) {
                VoxelIndex neighbor_voxel_idx = {center_ix + dx, center_iy + dy, center_iz + dz};
                auto it = grid.find(neighbor_voxel_idx);
                if (it != grid.end()) {
                    const std::vector<size_t>& point_indices = it->second;
                    for (size_t candidate_idx : point_indices) {
                        if (candidate_idx == query_idx) continue; 
                        if (distance_sq(query_point, cloud[candidate_idx]) <= radius_search_sq) {
                            neighbor_count++;
                        }
                    }
                }
            }
        }
    }
    return neighbor_count;
}